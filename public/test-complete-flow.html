<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Flow Test - React App Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            padding: 20px;
            margin: 0;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .test-section {
            background: #111;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .test-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px 5px;
            font-size: 14px;
        }
        .test-button:hover {
            background: #45a049;
        }
        .test-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            margin: 5px 0;
        }
        .status.success { background: #2d5a2d; }
        .status.error { background: #5a2d2d; }
        .status.info { background: #2d4a5a; }
        .status.warning { background: #5a5a2d; }
        .image-preview {
            max-width: 300px;
            border: 2px solid #333;
            margin: 10px 0;
        }
        .step {
            margin: 10px 0;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .step.error {
            border-left-color: #f44336;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üî¨ Complete Flow Test - React App Simulation</h1>
        <p>This simulates the exact same flow as the React app's "Test Image Generation" button.</p>

        <div class="test-section">
            <h2>üöÄ Test Complete Flow</h2>
            <p>This will test the entire flow: API call ‚Üí Image generation ‚Üí Compositing ‚Üí Final result</p>
            <button class="test-button" onclick="runCompleteTest()" id="testButton">Run Complete Test</button>
            <div id="main-status"></div>
            <div id="main-log" class="log"></div>
        </div>

        <div class="test-section">
            <h2>üìä Test Results</h2>
            <div id="results"></div>
        </div>
    </div>

    <script>
        // Simulate the exact same configuration as the React app
        const baseURL = 'http://localhost';
        const txt2imgURL = `${baseURL}:5001/api/txt2img`;
        const imagesURL = `${baseURL}:5001/api/images`;

        function log(elementId, message) {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            element.textContent += logMessage;
            element.scrollTop = element.scrollHeight;
            console.log(message);
        }

        function setStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function addStepResult(stepName, success, message, details = '') {
            const resultsDiv = document.getElementById('results');
            const stepDiv = document.createElement('div');
            stepDiv.className = `step ${success ? '' : 'error'}`;
            stepDiv.innerHTML = `
                <strong>${stepName}:</strong> ${success ? '‚úÖ' : '‚ùå'} ${message}
                ${details ? `<br><small>${details}</small>` : ''}
            `;
            resultsDiv.appendChild(stepDiv);
        }

        async function runCompleteTest() {
            const button = document.getElementById('testButton');
            const statusId = 'main-status';
            const logId = 'main-log';
            
            button.disabled = true;
            button.textContent = 'Running Test...';
            
            setStatus(statusId, 'Starting complete flow test...', 'info');
            document.getElementById(logId).textContent = '';
            document.getElementById('results').innerHTML = '';

            try {
                // Step 1: Random vibe selection
                log(logId, 'üé≤ Step 1: Random vibe selection');
                const vibes = ['Main Character', 'Healing Arc'];
                const randomVibe = vibes[Math.floor(Math.random() * vibes.length)];
                log(logId, `üéØ Selected vibe: ${randomVibe}`);
                addStepResult('Vibe Selection', true, `Selected: ${randomVibe}`);

                // Step 2: API Configuration
                log(logId, 'üîß Step 2: API Configuration');
                log(logId, `Base URL: ${baseURL}`);
                log(logId, `Txt2Img URL: ${txt2imgURL}`);
                log(logId, `Images URL: ${imagesURL}`);
                addStepResult('API Configuration', true, 'URLs configured correctly');

                // Step 3: Generate Disc Cover
                log(logId, 'üöÄ Step 3: Generate Disc Cover');
                const generationResponse = await generateDiscCover(randomVibe, 'calm', 'Test Playlist');
                addStepResult('API Generation', true, 'Image generated successfully', `Filename: ${generationResponse.generated_images[0].filename}`);

                // Step 4: Get Image URL
                log(logId, 'üîó Step 4: Get Image URL');
                const generatedImageFilename = generationResponse.generated_images[0].filename;
                const generatedImageUrl = `${imagesURL}/${generatedImageFilename}`;
                log(logId, `Generated image URL: ${generatedImageUrl}`);
                addStepResult('Image URL Creation', true, 'URL created successfully', generatedImageUrl);

                // Step 5: Test Image Loading
                log(logId, 'üñºÔ∏è Step 5: Test Image Loading');
                const imageLoaded = await testImageLoad(generatedImageUrl);
                addStepResult('Image Loading', imageLoaded.success, imageLoaded.message, imageLoaded.details);

                if (!imageLoaded.success) {
                    throw new Error(`Image loading failed: ${imageLoaded.message}`);
                }

                // Step 6: Test Compositing
                log(logId, 'üîÑ Step 6: Test Compositing');
                const compositingResult = await testCompositing(generatedImageUrl);
                addStepResult('Image Compositing', compositingResult.success, compositingResult.message, compositingResult.details);

                if (!compositingResult.success) {
                    throw new Error(`Compositing failed: ${compositingResult.message}`);
                }

                // Step 7: Final Result
                log(logId, '‚ú® Step 7: Final Result');
                log(logId, `Final composite image URL: ${compositingResult.finalImageUrl}`);
                addStepResult('Final Result', true, 'Complete flow successful!', `Final image: ${compositingResult.finalImageUrl}`);

                // Show final image
                const resultsDiv = document.getElementById('results');
                const finalImageDiv = document.createElement('div');
                finalImageDiv.innerHTML = `
                    <h3>üéâ Final Generated Image:</h3>
                    <img src="${compositingResult.finalImageUrl}" class="image-preview" alt="Final generated image">
                `;
                resultsDiv.appendChild(finalImageDiv);

                setStatus(statusId, '‚úÖ Complete flow test successful!', 'success');

            } catch (error) {
                log(logId, `‚ùå Test failed: ${error.message}`);
                setStatus(statusId, `‚ùå Test failed: ${error.message}`, 'error');
                addStepResult('Test Failure', false, error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'Run Complete Test';
            }
        }

        async function generateDiscCover(vibe, mood, playlistName) {
            const prompts = {
                'Main Character': `vibrant energetic gradient disc, bold colors, dynamic transitions, electric blues, bright purples, neon accents, high contrast, energetic mood, modern digital art, circular vinyl disc, subtle noise texture, playful UI design, 300x300px, square, high quality, contemporary`,
                'Healing Arc': `softer gradient palette, calming tones, gentle blues, soft purples, muted greens, peaceful transitions, zen-like atmosphere, healing mood, modern digital art, circular vinyl disc, subtle noise texture, calming UI design, 300x300px, square, high quality, serene`
            };

            const negativePrompts = {
                'Main Character': 'hard edges, sharp lines, geometric patterns, text, logos, borders, frames, blocks, tiles, mosaic, checkerboard, stripes, lines, sharp transitions, defined areas, sections, compartments, solid colors, flat colors, uniform colors, square composition, rectangular, vintage, film grain, old, worn',
                'Healing Arc': 'hard edges, sharp lines, geometric patterns, text, logos, borders, frames, blocks, tiles, mosaic, checkerboard, stripes, lines, sharp transitions, defined areas, sections, compartments, solid colors, flat colors, uniform colors, square composition, rectangular, vintage, film grain, old, worn, dark, gloomy'
            };

            const prompt = prompts[vibe];
            const negativePrompt = negativePrompts[vibe];
            const enhancedPrompt = `${prompt}, inspired by "${playlistName}"`;

            const payload = {
                prompt: enhancedPrompt,
                negative_prompt: negativePrompt,
                model_name: "stable-diffusion-v1-5.safetensors",
                steps: 25,
                cfg: 6.5,
                width: 300,
                height: 300,
                batch_size: 1,
                seed: Math.floor(Math.random() * 1000000)
            };

            const response = await fetch(txt2imgURL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            if (data.status !== 'success' || !data.generated_images?.length) {
                throw new Error(data.message || 'No images generated');
            }

            return data;
        }

        async function testImageLoad(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Same as our app
                
                img.onload = () => {
                    resolve({
                        success: true,
                        message: 'Image loaded successfully',
                        details: `Dimensions: ${img.width}x${img.height}`
                    });
                };
                
                img.onerror = (error) => {
                    resolve({
                        success: false,
                        message: 'Image loading failed',
                        details: `CORS or network error: ${error}`
                    });
                };
                
                img.src = imageUrl;
            });
        }

        async function testCompositing(generatedImageUrl) {
            try {
                // Load the generated image
                const generatedImage = await loadImage(generatedImageUrl);
                
                // Load NewCDbackground (fallback to solid disc if not available)
                let discBaseImage;
                try {
                    discBaseImage = await loadImage('/images/NewCDbackground.png');
                } catch (error) {
                    console.warn('NewCDbackground not found, creating solid disc');
                    discBaseImage = createSolidDisc(300);
                }

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 300;
                const ctx = canvas.getContext('2d');

                if (!ctx) {
                    throw new Error('Could not get canvas context');
                }

                // Draw disc base as background
                ctx.drawImage(discBaseImage, 0, 0, 300, 300);

                // Create circular mask for generated image
                const centerX = 150;
                const centerY = 150;
                const outerRadius = 114; // 38% of 300
                const innerRadius = 18; // 6% of 300

                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
                ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI, true);
                ctx.clip();

                // Draw generated image on top
                ctx.drawImage(generatedImage, 0, 0, 300, 300);
                ctx.restore();

                const finalImageUrl = canvas.toDataURL('image/png');

                return {
                    success: true,
                    message: 'Compositing successful',
                    details: `Final image size: ${canvas.width}x${canvas.height}`,
                    finalImageUrl: finalImageUrl
                };

            } catch (error) {
                return {
                    success: false,
                    message: 'Compositing failed',
                    details: error.message
                };
            }
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function createSolidDisc(size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const centerX = size / 2;
            const centerY = size / 2;
            const outerRadius = size * 0.4;
            const innerRadius = size * 0.08;

            // Draw disc background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, size, size);

            // Draw disc
            ctx.fillStyle = '#888888';
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
            ctx.fill();

            // Draw center hole
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
            ctx.fill();

            // Convert to image
            const img = new Image();
            img.src = canvas.toDataURL();
            return img;
        }
    </script>
</body>
</html>
