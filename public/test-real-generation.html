<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Real Generation Debug</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            padding: 20px;
            margin: 0;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .test-section {
            background: #111;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .test-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px 5px;
            font-size: 14px;
        }
        .test-button:hover {
            background: #45a049;
        }
        .test-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .result-image {
            max-width: 300px;
            border: 2px solid #333;
            border-radius: 8px;
            margin: 10px 0;
        }
        .log {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            margin: 5px 0;
        }
        .status.success { background: #2d5a2d; }
        .status.error { background: #5a2d2d; }
        .status.info { background: #2d4a5a; }
        .disc-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }
        .disc-image {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            border: 3px solid #666;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üêõ Test Real Generation Debug</h1>
        <p>This page tests the exact same flow as the React app to debug issues.</p>

        <!-- Test 1: Check NewCDbackground.png -->
        <div class="test-section">
            <h2>Test 1: Check NewCDbackground.png</h2>
            <p>Verify the NewCDbackground.png file is accessible.</p>
            <button class="test-button" onclick="testNewCDBackground()">Test NewCDbackground.png</button>
            <div id="background-status"></div>
            <div id="background-log" class="log"></div>
            <img id="background-result" class="result-image" style="display: none;" />
        </div>

        <!-- Test 2: Generate Disc Image -->
        <div class="test-section">
            <h2>Test 2: Generate Disc Image</h2>
            <p>Generate a disc image using the new API method.</p>
            <button class="test-button" onclick="testDiscGeneration()">Generate Disc Image</button>
            <div id="disc-status"></div>
            <div id="disc-log" class="log"></div>
            <img id="disc-result" class="result-image" style="display: none;" />
        </div>

        <!-- Test 3: Complete Compositing -->
        <div class="test-section">
            <h2>Test 3: Complete Compositing</h2>
            <p>Test the complete compositing process.</p>
            <button class="test-button" onclick="testCompleteCompositing()">Test Complete Compositing</button>
            <div id="composite-status"></div>
            <div id="composite-log" class="log"></div>
            <div class="disc-container">
                <img id="composite-result" class="disc-image" style="display: none;" />
            </div>
        </div>

        <!-- Test 4: React App Flow -->
        <div class="test-section">
            <h2>Test 4: React App Flow</h2>
            <p>Test the exact same flow as the React app.</p>
            <button class="test-button" onclick="testReactAppFlow()">Test React App Flow</button>
            <div id="react-status"></div>
            <div id="react-log" class="log"></div>
            <div class="disc-container">
                <img id="react-result" class="disc-image" style="display: none;" />
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'http://localhost:5001';
        const TXT2IMG_URL = `${API_BASE_URL}/api/txt2img`;
        const IMAGES_URL = `${API_BASE_URL}/api/images`;

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            element.textContent += logMessage;
            element.scrollTop = element.scrollHeight;
            console.log(message);
        }

        function setStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        async function testNewCDBackground() {
            const statusId = 'background-status';
            const logId = 'background-log';
            const resultId = 'background-result';

            setStatus(statusId, 'Testing NewCDbackground.png...', 'info');
            document.getElementById(logId).textContent = '';
            document.getElementById(resultId).style.display = 'none';

            try {
                log(logId, 'üîÑ Loading NewCDbackground.png...');
                const img = new Image();
                img.onload = () => {
                    log(logId, `‚úÖ NewCDbackground.png loaded successfully: ${img.width}x${img.height}`);
                    document.getElementById(resultId).src = img.src;
                    document.getElementById(resultId).style.display = 'block';
                    setStatus(statusId, '‚úÖ NewCDbackground.png accessible!', 'success');
                };
                img.onerror = () => {
                    log(logId, `‚ùå Failed to load NewCDbackground.png`);
                    setStatus(statusId, '‚ùå NewCDbackground.png not accessible', 'error');
                };
                img.src = '/images/NewCDbackground.png';
            } catch (error) {
                log(logId, `‚ùå Error: ${error.message}`);
                setStatus(statusId, `‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function testDiscGeneration() {
            const statusId = 'disc-status';
            const logId = 'disc-log';
            const resultId = 'disc-result';

            setStatus(statusId, 'Generating disc image...', 'info');
            document.getElementById(logId).textContent = '';
            document.getElementById(resultId).style.display = 'none';

            try {
                log(logId, 'üé® Generating disc image with optimized prompts...');
                
                const payload = {
                    prompt: "circular gradient artwork, smooth color transitions, soft blues, gentle purples, flowing blend, ethereal, dreamy, organic, seamless, watercolor effect, soft edges, atmospheric, calm mood, perfect circle, disc art, 300x300px, square, high quality, artistic",
                    negative_prompt: "hard edges, sharp lines, geometric patterns, grid, squares, rectangles, text, logos, borders, frames, blocks, tiles, mosaic, checkerboard, stripes, lines, sharp transitions, defined areas, sections, compartments, solid colors, flat colors, uniform colors, square composition, rectangular",
                    model_name: "stable-diffusion-v1-5.safetensors",
                    steps: 25,
                    cfg: 6.5,
                    width: 300,
                    height: 300,
                    batch_size: 1,
                    seed: Math.floor(Math.random() * 1000000)
                };

                log(logId, `üì¶ Payload: ${JSON.stringify(payload, null, 2)}`);

                const response = await fetch(TXT2IMG_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                });

                log(logId, `üì° Response status: ${response.status}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                log(logId, `üìÑ Response data: ${JSON.stringify(data, null, 2)}`);

                if (data.status !== 'success' || !data.generated_images?.length) {
                    throw new Error(`API Error: ${data.message || 'No images generated'}`);
                }

                const generatedImageFilename = data.generated_images[0].filename;
                const imageUrl = `${IMAGES_URL}/${generatedImageFilename}`;
                
                log(logId, `üñºÔ∏è Generated image: ${generatedImageFilename}`);
                log(logId, `üîó Image URL: ${imageUrl}`);

                // Test if image is accessible
                const img = new Image();
                img.onload = () => {
                    log(logId, `‚úÖ Generated image loaded successfully: ${img.width}x${img.height}`);
                    document.getElementById(resultId).src = imageUrl;
                    document.getElementById(resultId).style.display = 'block';
                    setStatus(statusId, '‚úÖ Disc image generated successfully!', 'success');
                };
                img.onerror = () => {
                    log(logId, `‚ùå Failed to load generated image from: ${imageUrl}`);
                    setStatus(statusId, '‚ùå Generated image not accessible', 'error');
                };
                img.src = imageUrl;

            } catch (error) {
                log(logId, `‚ùå Error: ${error.message}`);
                setStatus(statusId, `‚ùå Disc generation failed: ${error.message}`, 'error');
            }
        }

        async function testCompleteCompositing() {
            const statusId = 'composite-status';
            const logId = 'composite-log';
            const resultId = 'composite-result';

            setStatus(statusId, 'Testing complete compositing...', 'info');
            document.getElementById(logId).textContent = '';
            document.getElementById(resultId).style.display = 'none';

            try {
                log(logId, 'üé® Starting complete compositing test...');

                // Step 1: Generate an image
                log(logId, 'Step 1: Generating disc image...');
                const payload = {
                    prompt: "circular gradient artwork, smooth color transitions, soft blues, gentle purples, flowing blend, ethereal, dreamy, organic, seamless, watercolor effect, soft edges, atmospheric, calm mood, perfect circle, disc art, 300x300px, square, high quality, artistic",
                    negative_prompt: "hard edges, sharp lines, geometric patterns, grid, squares, rectangles, text, logos, borders, frames, blocks, tiles, mosaic, checkerboard, stripes, lines, sharp transitions, defined areas, sections, compartments, solid colors, flat colors, uniform colors, square composition, rectangular",
                    model_name: "stable-diffusion-v1-5.safetensors",
                    steps: 25,
                    cfg: 6.5,
                    width: 300,
                    height: 300,
                    batch_size: 1,
                    seed: Math.floor(Math.random() * 1000000)
                };

                const response = await fetch(TXT2IMG_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                const data = await response.json();
                if (data.status !== 'success' || !data.generated_images?.length) {
                    throw new Error('Failed to generate image for compositing test');
                }

                const generatedImageFilename = data.generated_images[0].filename;
                const generatedImageUrl = `${IMAGES_URL}/${generatedImageFilename}`;
                
                log(logId, `‚úÖ Generated image: ${generatedImageFilename}`);

                // Step 2: Test compositing
                log(logId, 'Step 2: Loading NewCDbackground.png...');
                const newCDBackground = await loadImage('/images/NewCDbackground.png');
                log(logId, `‚úÖ NewCDbackground loaded: ${newCDBackground.width}x${newCDBackground.height}`);

                log(logId, 'Step 3: Loading generated image...');
                const generatedImage = await loadImage(generatedImageUrl);
                log(logId, `‚úÖ Generated image loaded: ${generatedImage.width}x${generatedImage.height}`);

                log(logId, 'Step 4: Creating canvas for compositing...');
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 300;
                const ctx = canvas.getContext('2d');

                log(logId, 'Step 5: Drawing NewCDbackground...');
                ctx.drawImage(newCDBackground, 0, 0, 300, 300);

                log(logId, 'Step 6: Creating circular mask...');
                const centerX = 150; // Center horizontally
                const centerY = 150; // Center vertically
                const outerRadius = 300 * 0.38; // 76% of half size
                const innerRadius = 300 * 0.06; // 12% of half size

                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
                ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI, true); // Inner hole
                ctx.clip();

                log(logId, 'Step 7: Drawing generated image on top...');
                ctx.drawImage(generatedImage, 0, 0, 300, 300);
                ctx.restore();

                const finalImageUrl = canvas.toDataURL('image/png');
                log(logId, `‚úÖ Compositing complete! Final image: ${finalImageUrl.substring(0, 50)}...`);

                document.getElementById(resultId).src = finalImageUrl;
                document.getElementById(resultId).style.display = 'block';
                setStatus(statusId, '‚úÖ Complete compositing successful!', 'success');

            } catch (error) {
                log(logId, `‚ùå Error: ${error.message}`);
                setStatus(statusId, `‚ùå Compositing failed: ${error.message}`, 'error');
            }
        }

        async function testReactAppFlow() {
            const statusId = 'react-status';
            const logId = 'react-log';
            const resultId = 'react-result';

            setStatus(statusId, 'Testing React app flow...', 'info');
            document.getElementById(logId).textContent = '';
            document.getElementById(resultId).style.display = 'none';

            try {
                log(logId, 'üéÆ Testing exact React app flow...');

                // Simulate the app's flow
                const vibe = 'Main Character';
                const imageTheme = 'gradients'; // Main Character maps to gradients
                const mood = 'calm';
                const playlistName = 'Test Playlist';

                log(logId, `Selected vibe: ${vibe} ‚Üí Image theme: ${imageTheme}`);
                log(logId, `Mood: ${mood}, Playlist: ${playlistName}`);

                // Generate image using the same logic as the app
                const prompt = "circular gradient artwork, smooth color transitions, soft blues, gentle purples, flowing blend, ethereal, dreamy, organic, seamless, watercolor effect, soft edges, atmospheric, calm mood, perfect circle, disc art, 300x300px, square, high quality, artistic";
                const negativePrompt = "hard edges, sharp lines, geometric patterns, grid, squares, rectangles, text, logos, borders, frames, blocks, tiles, mosaic, checkerboard, stripes, lines, sharp transitions, defined areas, sections, compartments, solid colors, flat colors, uniform colors, square composition, rectangular";
                
                log(logId, `Using prompt: ${prompt.substring(0, 100)}...`);

                const payload = {
                    prompt: prompt,
                    negative_prompt: negativePrompt,
                    model_name: "stable-diffusion-v1-5.safetensors",
                    steps: 25,
                    cfg: 6.5,
                    width: 300,
                    height: 300,
                    batch_size: 1,
                    seed: Math.floor(Math.random() * 1000000)
                };

                const response = await fetch(TXT2IMG_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                const data = await response.json();
                if (data.status !== 'success' || !data.generated_images?.length) {
                    throw new Error('Failed to generate image');
                }

                const generatedImageFilename = data.generated_images[0].filename;
                const generatedImageUrl = `${IMAGES_URL}/${generatedImageFilename}`;
                
                log(logId, `‚úÖ Generated image: ${generatedImageFilename}`);

                // Composite the disc (same as React app)
                const finalImageUrl = await compositeDiscCover(generatedImageUrl);
                
                log(logId, `‚úÖ React app flow test successful!`);
                document.getElementById(resultId).src = finalImageUrl;
                document.getElementById(resultId).style.display = 'block';
                setStatus(statusId, '‚úÖ React app flow successful!', 'success');

            } catch (error) {
                log(logId, `‚ùå Error: ${error.message}`);
                setStatus(statusId, `‚ùå React app flow failed: ${error.message}`, 'error');
            }
        }

        // Helper functions
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
                img.src = src;
            });
        }

        async function compositeDiscCover(generatedImageUrl) {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');

            // Load NewCDbackground
            const newCDBackground = await loadImage('/images/NewCDbackground.png');
            ctx.drawImage(newCDBackground, 0, 0, 300, 300);

            // Load generated image
            const generatedImage = await loadImage(generatedImageUrl);

            // Create circular mask
            const centerX = 150; // Center horizontally
            const centerY = 150; // Center vertically
            const outerRadius = 300 * 0.38; // 76% of half size
            const innerRadius = 300 * 0.06; // 12% of half size

            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
            ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI, true);
            ctx.clip();

            // Draw generated image
            ctx.drawImage(generatedImage, 0, 0, 300, 300);
            ctx.restore();

            return canvas.toDataURL('image/png');
        }
    </script>
</body>
</html>
